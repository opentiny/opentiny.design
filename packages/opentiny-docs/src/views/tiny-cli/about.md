<h1 id='about'>关于</h1>

---
<h2 id='definition'>TinyCLI 是什么？</h2>

TinyCLI 是前端工程化的核心工具。旨在为开发者提供一系列健壮的工具、套件、插件和工作流，基于统一的开发环境，保证团队开发过程的一致性和可复制性。

TinyCLI 提供了类似[`yeoman`](http://yeoman.io/)的脚手架功能，让你快速的搭建本地开发环境；同时提供了类似于[`gulp`](http://gulpjs.com/)的插件机制，用于解决前端开发过程中的各类问题。

TinyCLI 的设计思想来源于 npm，npm 本身不具备太多的功能，只是一个包管理工具。TinyCLI 也是一样，TinyCLI 本身不具备任何工程化能力，TinyCLI 只是提供了一个让你写套件(脚手架)、写插件的平台，该平台可以安装、管理、运行对应的套件/插件。

<h2 id='features'>功能特性</h2>

1. 💻 **跨平台**，兼容 windows、mac、linux 三个平台
2. 🛠 **插件体系**，丰富的效率插件、可信插件、流程插件等，覆盖从开发->构建->发布的所有生命周期
3. 📦 **开箱即用**，结合丰富的经验沉淀出的项目开发最佳实践，提供基于主流业务场景的项目解决方案
4. ⏳ **任务流机制**，提供了比 npm scripts 更强大的任务流运行机制
5. 🏹 **自动升级**，无需手动安装和升级插件，这一切都是自动化完成

TinyCLI 的功能特性远不止这些，更多功能特性，等待你发掘。

<h2 id='select'>为什么选择 TinyCLI ?</h2>

对于一个前端团队来说，需要怎么样的 cli？这个问题，我们先试想下如下的一些场景：

1. **技术栈多样化**：一个前端团队的项目工程模板往往不止一个，比如基于 vue 的单页面应用模板、PEP 的页面和楼层组件开发模板、nodejs 项目开发模板、XXX 业务开发模板等等。**如何让 cli 拥有能够支持多种业务形态，具有良好的可扩展性？**
2. **存量项目多**：一个团队的工程化进程肯定是不断积累与完善的，比如有些业务项目历史比较久用的是 jq 那套，可能都不需要编译的过程。**如何让 cli 工具如何兼容存量项目？**
3. **落地效果保障**：目前大部分团队都有研发规范，很多时候，规范就像一阵风，领导抓的时候，大家都在遵守，但是慢慢又会归于原位，人总是有惰性的，那么**基于 cli 如何保障规范的落地和执行效果？**
4. **项目共性问题**：比如一般每个项目都可能会有 eslint、pretter 这些代码规范及格式的环境及配置；与公司环境相关的，比如 code Review、代码发布等等，这些属于项目共性问题，是否每套工程模板都要各自去搞一套这些环境？是否可以通过插件、中间件或者其他切片方式将这些共性问题抽象出来，单独进行初始化或使用？
5. **项目升级问题**：前端技术日新月异，就我们最常用的 webpack 就已经到 webpack4 了，**如何让已初始化的项目能批量升级技术栈？**再比如 eslint 规范，规范更新了，怎么保证每个项目的 eslint 配置文件升级、项目工程 bug 如何快速修复等。
6. **环境容错问题**：开发过程中会遇到很多 nodejs 环境问题，比如端口占用、webpack 构建失败、依赖包缺失等，**基于 cli 能否更优雅的解决环境问题**，让开发者聚焦业务上？
7. **大数据统计**：大家都在用这个工具，**通过什么方式可以收集一些共性信息？**比如 大家项目里都依赖了哪些常用的 npm 包，大家项目的 eslint 通过率怎么样？甚至可以基于这个工具看一下大家的开发时间主要集中在哪个时间段。

每个团队的业务特征不一样，场景也非常多，定义好核心场景，是设计一个满足团队诉求的 cli 的前提。
tiny-cli 的核心思想是通过提供套件与插件及任务流等能力，由团队，由用户根据自身的核心场景来拆分为套件与插件来解决各类场景问题：

<h3 id='kit'>套件</h3>

模板管理是这个 cli 工具的核心功能之一。模板管理这个好理解，大名鼎鼎的 yeoman 估计蛮多人都用过，他其中一个核心能力是可以安装各种 generator 来丰富自己的生态体系。基于这种平台式的架构有个最大的好处：**可以让前端参与到这个工具生态里面共建模板，同时也能应对各种类型的项目，可扩展性高**。

同时在 tiny-cli 套件中，通过通用的命令结合任务流功能，相比 yeoman 提供了更强大的控制能力与灵活性。

<h3 id='plugin'>插件</h3>

而插件的概念与模板稍微有些区别，模板主要解决的是项目层面的事情，比如项目工程初始化，打包编译等事情。而插件侧重于**解决项目间的共性问题**，如上面场景的第四点。举个例子，比如一个 eslint 插件，功能可包含：

1. 初始化 eslint 运行环境
2. 运行 eslint
3. 在项目的添加 git hooks，当执行 git commit 时自动触发 eslint

基于这个插件，无论在什么项目中，都能快速接入 eslint。类似的，基于插件机制，我们可以开发出各种项目小插件，如：

1. 效率提升类：mock 服务插件、前端资源代理插件、前端项目依赖分析插件等。
2. 流程优化类：git 操作封装插件、前端资源发布 CDN 插件等。
3. 质量保障类：console 检测插件、快速搭建测试环境插件、prettier 插件等。
